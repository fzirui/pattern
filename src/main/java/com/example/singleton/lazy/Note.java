package com.example.singleton.lazy;

public class Note {
    /**
     * 懒汉式单例
     *  被调用时才会创建实例
     *  优点：被调用时才会创建实例,不会造成空间浪费
     *  缺点：存在线程安全问题,需要加锁
     *  1.普通式（LazySingleton）
     *      在方法上加 synchronize,在一个线程执行并调用 getInstance()方法时
     *      另一个线程再调用 getInstance()方法,该线程的状态会从 RUNNING 变成 MONITOR,出现阻塞
     *      直到第一个线程执行完,第二个线程才会恢复成 RUNNING,继续执行
     *    在线程较多的情况下,会导致大量线程出现阻塞
     *
     *  2.双重检查锁式（LazyDCLSingleton）
     *      检查到第一个判断,实例不为 null,则直接返回不需要加锁
     *      若第一个判断实例为 null,由于加了锁,只会有一个线程进入创建对象
     *      当获取锁的线程完成创建对象后,其他的线程再次判断时一定不为 null,则直接返回创建好的实例对象
     *
     *  3.静态内部类式（LazyInnerClassSingleton）
     *      内部类默认不加载,当调用 getInstance()方法时才会加载内部类
     *    避免了饿汉式的内存资源浪费,又未使用锁,内部类一定是在方法调用之前初始化,避免了线程安全问题
     *
     *  创建对象的过程：
     *      1.为对象分配内存空间
     *      2.初始化对象
     *      3.将引用指向该对象的内存地址
     *    若编译器将指令重排：132,会造成第一个判断实例不为 null,因为该引用指向了内存地址,地址存在但对象还未初始化
     *    会直接返回一个还未初始化的对象的内存地址
     *    解决：使用 volatile
     */
}
